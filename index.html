<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Duelo de Cartas — P2P (escolha simultânea)</title>
  <meta name="description" content="Duelo 1x1 com WebRTC/PeerJS; movimentos: Ataque, Bloqueio, Esquiva, Ataque Forte. Revela resultado quando ambos escolherem.">
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <style>
    :root{
      --bg:#0b0c14; --fg:#E8ECF1; --muted:#A9B3C1;
      --panel:#121729; --edge:#2b3045;
      --accent:#eab308; --danger:#ef4444; --ok:#22c55e;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; background:var(--bg); color:var(--fg); font:16px/1.45 system-ui,Segoe UI,Roboto,Arial; display:flex; justify-content:center; align-items:center; padding:16px}
    .wrap{width:min(920px,100%); display:flex; flex-direction:column; gap:16px}
    .card{background:var(--panel); border:1px solid var(--edge); border-radius:16px; padding:16px}
    h1{margin:0 0 .25rem 0; font-size:clamp(20px,3.2vw,28px)}
    .row{display:flex; gap:12px; flex-wrap:wrap; align-items:center}
    input[type=text]{flex:1; min-width:180px; padding:.7rem .9rem; border-radius:10px; border:1px solid var(--edge); background:#0f1322; color:#e8ecf1}
    button{padding:.7rem 1rem; border-radius:10px; border:1px solid var(--edge); background:#19203a; color:#e8ecf1; cursor:pointer}
    button[disabled]{opacity:.6; cursor:not-allowed}
    .badge{display:inline-flex; gap:8px; align-items:center; padding:.35rem .6rem; border-radius:999px; border:1px solid var(--edge); background:#0f1322; color:#e8ecf1}
    .hpbar{height:14px; background:#0f1322; border:1px solid var(--edge); border-radius:999px; overflow:hidden; min-width:160px}
    .hpbar>div{height:100%; background:linear-gradient(90deg,var(--ok),#16a34a); width:100%}
    .arena{display:grid; grid-template-columns:1fr; gap:12px}
    @media (min-width:720px){ .arena{grid-template-columns:1fr 1fr} }
    .actions{display:grid; grid-template-columns:repeat(2, minmax(120px,1fr)); gap:12px}
    .move{display:flex; flex-direction:column; gap:6px; align-items:center; justify-content:center; min-height:72px;
          border:1px solid var(--edge); border-radius:12px; background:#10182e}
    .move.playable{outline:2px solid var(--accent); box-shadow:0 0 0 3px rgba(234,179,8,.2)}
    .muted{color:var(--muted)}
    .status{font-weight:600}
    .log{background:#0f1322; border:1px solid var(--edge); border-radius:12px; padding:12px; max-height:180px; overflow:auto; white-space:pre-wrap}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Duelo de Cartas — P2P (simultâneo)</h1>
      <div class="row">
        <input id="room" type="text" placeholder="Palavra-chave (ex.: sintetizo-42)" maxlength="24" />
        <label><input type="radio" name="r" value="A" checked> A</label>
        <label><input type="radio" name="r" value="B"> B</label>
        <button id="connect">Conectar</button>
      </div>
      <div class="row">
        <span id="you" class="badge">Você: ?</span>
        <span id="conn" class="badge">Desconectado</span>
      </div>
      <small class="muted">Abra este mesmo arquivo no celular. HTTPS recomendado (GitHub Pages).</small>
    </div>

    <div class="card arena">
      <div>
        <div class="row"><strong>Oponente</strong> <span id="oppSym" class="badge">?</span></div>
        <div class="hpbar"><div id="oppHP"></div></div>
      </div>
      <div>
        <div class="row"><strong>Você</strong> <span id="meSym" class="badge">?</span></div>
        <div class="hpbar"><div id="meHP"></div></div>
      </div>
    </div>

    <div class="card">
      <div id="status" class="row status">Status: —</div>
      <div id="actions" class="actions"></div>
      <div class="row">
        <button id="next" disabled>Próxima rodada</button>
        <button id="reset" disabled>Reiniciar partida</button>
      </div>
      <div class="log" id="log"></div>
      <small class="muted">Movimentos: <b>Ataque</b> (3), <b>Ataque Forte</b> (5), <b>Bloqueio</b> (-3 de dano recebido), <b>Esquiva</b> (anula Ataque; não evita Forte).</small>
    </div>
  </div>

  <script>
    // Config
    const HP_INICIAL = 15;
    const MOVES = ["ATAQUE", "BLOQUEIO", "ESQUIVA", "FORTE"];
    const DMG = { ATAQUE:3, FORTE:5 };
    const BLOCK_VAL = 3;

    // Estado
    let me = "?";      // "A" ou "B"
    let opp = "?";
    let state = null;  // mantido por A
    let conn = null;   // DataConnection
    let peer = null;   // Peer local
    let role = "A";    // padrão
    let myChoice = null;

    const $room = document.getElementById('room');
    const $connect = document.getElementById('connect');
    const $you = document.getElementById('you');
    const $conn = document.getElementById('conn');
    const $oppSym = document.getElementById('oppSym');
    const $meSym = document.getElementById('meSym');
    const $oppHP = document.getElementById('oppHP');
    const $meHP = document.getElementById('meHP');
    const $status = document.getElementById('status');
    const $actions = document.getElementById('actions');
    const $next = document.getElementById('next');
    const $reset = document.getElementById('reset');
    const $log = document.getElementById('log');

    document.querySelectorAll('input[name="r"]').forEach(r=>{
      r.addEventListener('change', ()=>{ role = r.value; });
    });

    function resetState(){
      state = {
        hp:{A:HP_INICIAL, B:HP_INICIAL},
        pending:{A:null, B:null},  // escolhas da rodada
        reveal:false,               // true quando ambos escolheram
        last:{A:null, B:null},      // últimas escolhas reveladas
        delta:{A:0, B:0},           // dano recebido na última rodada
        round:1,
        status:"Rodada 1 — escolham seus movimentos."
      };
      myChoice = null;
      $log.textContent = "";
    }

    function render(){
      const myHP = (state?.hp?.[me] ?? HP_INICIAL);
      const opHP = (state?.hp?.[opp] ?? HP_INICIAL);
      $meHP.style.width = Math.max(0, Math.min(100, Math.round(myHP/HP_INICIAL*100))) + "%";
      $oppHP.style.width = Math.max(0, Math.min(100, Math.round(opHP/HP_INICIAL*100))) + "%";
      $meSym.textContent = me;
      $oppSym.textContent = opp;
      $status.textContent = "Status: " + (state?.status || "—");

      // Ações
      $actions.innerHTML = "";
      const canPick = conn && (!state.reveal) && state.hp[me] > 0 && state.hp[opp] > 0 && state.pending[me] == null;
      MOVES.forEach(mv=>{
        const b = document.createElement('button');
        b.className = 'move';
        b.textContent = labelMove(mv);
        if(canPick) b.classList.add('playable');
        b.disabled = !canPick;
        b.onclick = ()=> choose(mv);
        $actions.appendChild(b);
      });

      $next.disabled = !(conn && state.reveal);
      $reset.disabled = !conn;
    }

    function labelMove(mv){
      switch(mv){
        case "ATAQUE": return "Ataque (3)";
        case "FORTE": return "Ataque Forte (5)";
        case "BLOQUEIO": return "Bloqueio (-3 dano)";
        case "ESQUIVA": return "Esquiva (anula Ataque)";
        default: return mv;
      }
    }

    function logLine(txt){
      $log.textContent = (txt + "\n" + $log.textContent).slice(0, 4000);
    }

    // Resolver rodada (no A)
    function resolveRound(){
      const a = state.pending.A, b = state.pending.B;
      const dmgTo = {A:0, B:0};

      // Dano bruto
      const rawA = DMG[a] || 0;
      const rawB = DMG[b] || 0;

      // Defesa / regras
      // Bloqueio reduz 3 do dano recebido
      const blockA = (a === "BLOQUEIO") ? BLOCK_VAL : 0;
      const blockB = (b === "BLOQUEIO") ? BLOCK_VAL : 0;

      // Esquiva anula ATAQUE; não evita FORTE
      const dodgeA = (a === "ESQUIVA");
      const dodgeB = (b === "ESQUIVA");

      // Dano que A recebe do B
      let incomingA = rawB;
      if(dodgeA && b === "ATAQUE") incomingA = 0;
      incomingA = Math.max(0, incomingA - blockA);

      // Dano que B recebe do A
      let incomingB = rawA;
      if(dodgeB && a === "ATAQUE") incomingB = 0;
      incomingB = Math.max(0, incomingB - blockB);

      dmgTo.A = incomingA;
      dmgTo.B = incomingB;

      state.hp.A = Math.max(0, state.hp.A - dmgTo.A);
      state.hp.B = Math.max(0, state.hp.B - dmgTo.B);
      state.delta = dmgTo;
      state.last = {A:a, B:b};
      state.reveal = true;

      // Status
      const line = `Rodada ${state.round}: A ${labelMove(a)} × B ${labelMove(b)}  →  A sofreu ${dmgTo.A}, B sofreu ${dmgTo.B}.`;
      logLine(line);
      if(state.hp.A === 0 && state.hp.B === 0){
        state.status = `Rodada ${state.round} — Empate técnico! Ambos a 0.`;
      }else if(state.hp.A === 0){
        state.status = `Rodada ${state.round} — B venceu o duelo!`;
      }else if(state.hp.B === 0){
        state.status = `Rodada ${state.round} — A venceu o duelo!`;
      }else{
        state.status = `Rodada ${state.round} concluída. Clique "Próxima rodada".`;
      }
    }

    function choose(mv){
      myChoice = mv;
      if(me === "A"){
        state.pending.A = mv;
        // Se B já escolheu, resolve e envia; senão, apenas avisa progresso
        if(state.pending.B){
          resolveRound();
          sendState("reveal");
        }else{
          sendState("progress"); // não revela ainda
        }
        render();
      }else{
        // B apenas envia sua escolha para A
        if(conn && conn.open){
          conn.send({type:"choice", move: mv});
        }
        state.pending.B = mv; // localmente só para bloquear botões
        state.status = `Rodada ${state.round} — escolha feita; aguardando oponente…`;
        render();
      }
    }

    function nextRound(){
      if(me === "A"){
        state.round += 1;
        state.pending = {A:null, B:null};
        state.reveal = false;
        state.last = {A:null, B:null};
        state.delta = {A:0, B:0};
        state.status = `Rodada ${state.round} — escolham seus movimentos.`;
        sendState("state");
        render();
      }else if(conn && conn.open){
        conn.send({type:"next"});
      }
    }

    function resetMatch(){
      if(me === "A"){
        resetState();
        sendState("state");
        render();
      }else if(conn && conn.open){
        conn.send({type:"reset"});
      }
    }

    function sendState(kind){
      if(!conn || !conn.open) return;
      // Monta pacote: nunca envia a escolha pendente do oponente
      const payload = {
        hp: state.hp,
        round: state.round,
        reveal: state.reveal,
        last: state.reveal ? state.last : {A:null, B:null},
        delta: state.reveal ? state.delta : {A:0,B:0},
        pendingMe: state.pending.B, // para B saber se já escolheu
        status: state.status
      };
      conn.send({type: kind === "reveal" ? "reveal" : "state", state: payload});
    }

    function handleMessage(msg){
      if(msg.type === "choice"){
        // A recebeu a escolha de B
        if(me === "A"){
          state.pending.B = msg.move;
          if(state.pending.A){
            resolveRound();
            sendState("reveal");
          }else{
            // Só progresso
            state.status = `Rodada ${state.round} — oponente escolheu; aguarde sua decisão.`;
            sendState("state");
          }
          render();
        }
        return;
      }
      if(msg.type === "state"){
        // B recebe estado sem revelar escolha do A
        state = state || {};
        state.hp = msg.state.hp;
        state.round = msg.state.round;
        state.reveal = msg.state.reveal;
        state.last = msg.state.last;
        state.delta = msg.state.delta;
        state.status = msg.state.status;
        render();
        return;
      }
      if(msg.type === "reveal"){
        // B recebe resultado da rodada
        state = state || {};
        state.hp = msg.state.hp;
        state.round = msg.state.round;
        state.reveal = msg.state.reveal;
        state.last = msg.state.last;
        state.delta = msg.state.delta;
        state.status = msg.state.status;
        render();
        return;
      }
      if(msg.type === "next"){
        if(me === "A"){
          nextRound();
        }
        return;
      }
      if(msg.type === "reset"){
        if(me === "A"){
          resetMatch();
        }
        return;
      }
    }

    function connect(){
      const code = ($room.value||"").trim().toLowerCase();
      if(!code){ alert("Informe a palavra-chave da sala."); return; }
      me = role;
      opp = (me === "A") ? "B" : "A";
      $you.textContent = `Você: ${me}  (sala: ${code})`;

      const myId = `${code}-${me}`;
      const peerConfig = {
        debug: 2,
        config: {iceServers:[
          { urls: "stun:stun.l.google.com:19302" },
          { urls: "stun:stun1.l.google.com:19302" }
        ]}
      };
      peer = new Peer(myId, peerConfig);

      peer.on('open', id=>{
        $conn.textContent = 'Conectando…';
        const otherId = `${code}-${opp}`;
        function tryDial(){
          if(conn && conn.open) return;
          const c = peer.connect(otherId, {reliable:true});
          setupConn(c);
        }
        tryDial();
        const dialInt = setInterval(()=>{
          if(conn && conn.open){ clearInterval(dialInt); return; }
          tryDial();
        }, 1000);
      });

      peer.on('connection', c=> setupConn(c));
      peer.on('error', err=>{ console.error(err); $conn.textContent = 'Erro: ' + err.type; });

      function setupConn(c){
        c.on('open', ()=>{
          conn = c;
          $conn.textContent = 'Conectado';
          if(me === "A"){
            resetState();
            sendState("state");
          }else{
            state = {hp:{A:HP_INICIAL,B:HP_INICIAL},round:1,reveal:false,last:{A:null,B:null},delta:{A:0,B:0},status:"Conectado. Aguardando estado…", pending:{A:null,B:null}};
          }
          render();
        });
        c.on('data', data=> handleMessage(data));
        c.on('close', ()=>{ $conn.textContent = 'Desconectado'; conn = null; render(); });
      }
    }

    document.getElementById('connect').onclick = connect;
    $next.onclick = ()=> nextRound();
    $reset.onclick = ()=> resetMatch();

    // UI inicial
    state = {hp:{A:HP_INICIAL,B:HP_INICIAL},round:1,reveal:false,last:{A:null,B:null},delta:{A:0,B:0},status:"Aguardando conexão…", pending:{A:null,B:null}};
    render();
  </script>
</body>
</html>
